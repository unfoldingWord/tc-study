/**
 * Simplified Drizzle SQLite Storage Adapter
 * 
 * A React Native storage adapter that uses the DatabaseManager but with simplified
 * Drizzle usage to avoid bundling issues. Uses raw SQL queries where needed.
 */

import { DatabaseManager } from '../../../db/DatabaseManager';
import {
  QuotaInfo,
  ResourceContent,
  ResourceMetadata,
  StorageAdapter,
  StorageInfo,
  StorageTransaction,
  TableOfContents
} from '../../types/context';
import { ProcessedContent } from '../../types/processed-content';

// Import bundled resource loader (will be generated by resource-zip-bundler)
// Lazy load to avoid errors if the file doesn't exist yet
let bundledResourceLoader: any = null;
let loaderInitialized = false;

async function getBundledLoader() {
  if (loaderInitialized) {
    return bundledResourceLoader;
  }
  
  try {
    bundledResourceLoader = await import('../resources/bundled-resource-loader');
    loaderInitialized = true;
    console.log('‚úÖ Bundled resource loader loaded successfully');
    return bundledResourceLoader;
  } catch {
    loaderInitialized = true;
    bundledResourceLoader = null;
    console.log('‚ÑπÔ∏è Bundled resource loader not available');
    return null;
  }
}

export class SimplifiedDrizzleStorageAdapter implements StorageAdapter {
  private databaseManager: DatabaseManager;
  private isInitialized = false;

  constructor() {
    this.databaseManager = DatabaseManager.getInstance();
  }

  /**
   * Initialize the storage adapter
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    // Database manager is initialized globally in the app
    // Just initialize storage statistics
    await this.initializeStorageStats();
    
    this.isInitialized = true;
  }

  /**
   * Initialize storage statistics table
   */
  private async initializeStorageStats(): Promise<void> {
    const db = this.databaseManager.getSqliteDb();
    
    // Check if global stats exist, create if not
    const existingStats = await db.getFirstAsync(
      'SELECT * FROM storage_stats WHERE key = ? LIMIT 1',
      ['global']
    );
    
    if (!existingStats) {
      await db.runAsync(
        'INSERT INTO storage_stats (key, total_size, item_count, last_cleanup) VALUES (?, ?, ?, ?)',
        ['global', 0, 0, Date.now()]
      );
      
    }
  }

  /**
   * Get all resource metadata for a server/owner/language combination
   */
  async getResourceMetadata(server: string, owner: string, language: string): Promise<ResourceMetadata[]> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    

    const rows = await db.getAllAsync(
      'SELECT * FROM resource_metadata WHERE server = ? AND owner = ? AND language = ?',
      [server, owner, language]
    ) as any[];

    // Convert stored data back to proper types
    const metadata: ResourceMetadata[] = rows.map(row => ({
      id: row.id,
      resourceKey: row.resource_key,
      server: row.server,
      owner: row.owner,
      language: row.language,
      type: row.type as any, // ResourceType
      title: row.title,
      description: row.description || '',
      name: row.name,
      version: row.version,
      lastUpdated: new Date(row.last_updated),
      available: Boolean(row.available),
      toc: row.toc ? JSON.parse(row.toc) as TableOfContents : { books: [] },
      isAnchor: Boolean(row.is_anchor),
      
      // Language metadata
      languageDirection: row.language_direction as 'rtl' | 'ltr' | undefined,
      languageTitle: row.language_title || undefined,
      languageIsGL: row.language_is_gl ? Boolean(row.language_is_gl) : undefined,
      
      // SHA-based change detection
      commitSha: row.commit_sha || undefined,
      fileHashes: row.file_hashes ? JSON.parse(row.file_hashes) : undefined,
    }));

    // If no metadata found in DB, try to load from bundled assets or extracted files
    if (metadata.length === 0) {
      console.log(`üîç No metadata in DB for ${server}/${owner}/${language}, checking bundled assets...`);
      
      // Only try to load resources that are actually bundled for this language
      const resourceIdsToTry = await this.getResourceIdsForLanguage(language);
      const loadedMetadata: ResourceMetadata[] = [];
      
      for (const resourceId of resourceIdsToTry) {
        try {
          // First, try to load from bundled assets
          const bundleLoaded = await this.loadBundledResourceIfAvailable(
            server,
            owner,
            language,
            resourceId
          );
          
          if (bundleLoaded) {
            console.log(`üì¶ Bundled resource ${resourceId} loaded, now loading metadata...`);
          }
          
          // Now try to load metadata from extracted files (whether from bundle or previously extracted)
          const manifestData = await this.databaseManager.loadMetadataFromExtractedFiles(
            resourceId,
            server,
            owner,
            language
          );
          
          if (manifestData) {
            // Convert manifest data to ResourceMetadata format
            // This is a simplified conversion - adjust based on your actual manifest structure
            
            // Parse TOC if it's a string (from exported files)
            let toc: TableOfContents = { books: [] };
            if (manifestData.toc) {
              toc = typeof manifestData.toc === 'string' 
                ? JSON.parse(manifestData.toc) 
                : manifestData.toc;
              console.log(`üìö TOC loaded for ${resourceId}: ${toc.books?.length || 0} books`);
            } else if (manifestData.projects) {
              // Fallback to projects for older formats
              toc = this.convertProjectsToTOC(manifestData.projects);
              console.log(`üìö TOC converted from projects for ${resourceId}: ${toc.books?.length || 0} books`);
            }
            
            const resourceMetadata: ResourceMetadata = {
              id: resourceId,
              resourceKey: `${server}/${owner}/${language}/${resourceId}`,
              server,
              owner,
              language,
              type: this.inferResourceType(resourceId),
              title: manifestData.title || manifestData.dublin_core?.title || resourceId.toUpperCase(),
              description: manifestData.description || manifestData.dublin_core?.description || '',
              name: manifestData.name || manifestData.dublin_core?.title || resourceId.toUpperCase(),
              version: manifestData.version || manifestData.dublin_core?.version || '1.0',
              // Use Date.now() for bundled resources to indicate they're freshly loaded
              // This prevents ResourceManager from trying to fetch from network
              lastUpdated: new Date(),
              available: manifestData.available !== undefined ? Boolean(manifestData.available) : true,
              toc,
              isAnchor: manifestData.isAnchor !== undefined ? Boolean(manifestData.isAnchor) : resourceId === 'ult',
            };
            
            loadedMetadata.push(resourceMetadata);
            console.log(`‚úÖ Loaded metadata for ${resourceId}`);
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to load metadata for ${resourceId}:`, error);
        }
      }
      
      // Save loaded metadata to database for future use
      if (loadedMetadata.length > 0) {
        await this.saveResourceMetadata(loadedMetadata);
        return loadedMetadata;
      }
    }
    
    return metadata;
  }

  /**
   * Load a bundled resource if available
   * Returns true if resource was loaded, false otherwise
   */
  private async loadBundledResourceIfAvailable(
    server: string,
    owner: string,
    language: string,
    resourceId: string
  ): Promise<boolean> {
    const loader = await getBundledLoader();
    
    if (!loader) {
      return false;
    }

    const resourceKey = `${server}/${owner}/${language}/${resourceId}`;
    
    // Check if this resource is available as a bundle
    if (!loader.hasBundledResource(resourceKey)) {
      console.log(`‚ÑπÔ∏è Resource ${resourceKey} not available in bundles`);
      return false;
    }

    try {
      const resource = loader.getBundledResourceByKey(resourceKey);
      if (!resource) {
        return false;
      }

      // Check if resource is already extracted by looking for metadata file
      const metadataExists = await this.databaseManager.loadMetadataFromExtractedFiles(
        resourceId,
        server,
        owner,
        language
      );
      
      if (metadataExists) {
        console.log(`‚úÖ Bundled resource ${resourceKey} already extracted, skipping`);
        return true;
      }

      console.log(`üì¶ Extracting bundled resource: ${resourceKey}`);
      
      // Load and extract the bundled resource
      await loader.loadBundledResource(resource);
      console.log(`‚úÖ Bundled resource ${resourceKey} extracted successfully`);
      
      return true;
    } catch (error) {
      console.error(`‚ùå Failed to load bundled resource ${resourceKey}:`, error);
      return false;
    }
  }

  /**
   * Infer resource type from resource ID
   */
  private inferResourceType(resourceId: string): any {
    const typeMap: Record<string, string> = {
      'ult': 'scripture',
      'ust': 'scripture',
      'uhb': 'scripture',
      'ugnt': 'scripture',
      'tn': 'notes',
      'tq': 'questions',
      'tw': 'words',
      'twl': 'words-links',
      'ta': 'academy',
    };
    return typeMap[resourceId] || 'scripture';
  }

  /**
   * Convert manifest projects to TOC format
   */
  private convertProjectsToTOC(projects: any[]): TableOfContents {
    return {
      books: projects.map(proj => ({
        code: proj.identifier || proj.id,
        name: proj.title || proj.name,
        testament: (proj.testament || 'NT') as 'OT' | 'NT',
        chapters: proj.chapters
      }))
    };
  }

  /**
   * Generate a simple checksum for content integrity verification
   */
  private async generateChecksum(content: string): Promise<string> {
    // Use a simple hash function for checksum generation
    // In a production environment, you might want to use crypto.subtle.digest
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16);
  }

  /**
   * Get the resource IDs that are actually bundled for a specific language
   * This prevents trying to load resources that don't exist for that language
   */
  private async getResourceIdsForLanguage(language: string): Promise<string[]> {
    const loader = await getBundledLoader();
    if (!loader) {
      return []; // No bundled resources available
    }
    
    // Get available resource IDs from the bundled resource manifest for this language
    const manifest = loader.getResourceManifest();
    const resourcesForLanguage = manifest[language] || [];
    
    return resourcesForLanguage.map((r: any) => r.id);
  }

  /**
   * Save resource metadata to storage
   */
  async saveResourceMetadata(metadata: ResourceMetadata[]): Promise<void> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    

    for (const meta of metadata) {
      const resourceKey = `${meta.server}/${meta.owner}/${meta.language}/${meta.id}`;
      
      await db.runAsync(
        `INSERT OR REPLACE INTO resource_metadata 
         (resource_key, id, server, owner, language, type, title, description, name, version, 
          last_updated, available, is_anchor, toc, language_direction, language_title, 
          language_is_gl, commit_sha, file_hashes, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          resourceKey,
          meta.id,
          meta.server,
          meta.owner,
          meta.language,
          meta.type,
          meta.title,
          meta.description,
          meta.name,
          meta.version,
          meta.lastUpdated.getTime(),
          meta.available ? 1 : 0,
          meta.isAnchor ? 1 : 0,
          meta.toc ? JSON.stringify(meta.toc) : null,
          meta.languageDirection || null,
          meta.languageTitle || null,
          meta.languageIsGL ? 1 : null,
          meta.commitSha || null,
          meta.fileHashes ? JSON.stringify(meta.fileHashes) : null,
          Date.now()
        ]
      );
    }

    
  }

  /**
   * Get resource content by key
   */
  async getResourceContent(key: string): Promise<ResourceContent | null> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    let row = await db.getFirstAsync(
      'SELECT * FROM resource_content WHERE key = ?',
      [key]
    ) as any;

    // If not found in DB, try to load from bundled assets
    if (!row) {
      console.log(`üîç Content not in DB for key: ${key}, checking bundled assets...`);
      
      // Parse the key to extract resource info
      // Key format: server/owner/language/resourceId/bookCode or articleId
      // For entry resources, articleId may contain subdirectories (e.g., translate/grammar-connect-logic-goal)
      const keyParts = key.split('/');
      if (keyParts.length >= 5) {
        const server = keyParts[0];
        const owner = keyParts[1];
        const language = keyParts[2];
        const resourceId = keyParts[3];
        // Join all remaining parts as the identifier (handles subdirectories for entry resources)
        const identifier = keyParts.slice(4).join('/');
        
        // Try to load the bundled resource
        const bundleLoaded = await this.loadBundledResourceIfAvailable(
          server,
          owner,
          language,
          resourceId
        );
        
        if (bundleLoaded) {
          console.log(`üì¶ Bundled resource loaded, attempting to load content from extracted files...`);
          
          // Load content from extracted files
          // This returns a complete ResourceContent object ready for the database
          const resourceContentFromFile = await this.databaseManager.loadContentFromExtractedFiles(
            resourceId,
            identifier, // This is the bookCode or articleId
            server,
            owner,
            language
          );
          
          if (resourceContentFromFile) {
            // The .json.zip files contain complete ResourceContent objects
            // We just need to ensure the key matches what was requested
            const newContent: ResourceContent = {
              ...resourceContentFromFile,
              key, // Use the requested key
              lastFetched: new Date(), // Update fetch time
            };
            
            // Debug: Log content structure
            console.log(`üìù Saving content for ${key}:`, {
              type: newContent.type,
              contentKeys: Object.keys(newContent.content),
              hasNotes: !!(newContent.content as any).notes,
              hasArticle: !!(newContent.content as any).article,
              hasChapters: !!(newContent.content as any).chapters,
            });
            
            // Save to database for future use
            await this.saveResourceContent(newContent);
            console.log(`‚úÖ Content loaded and saved for ${key}`);
            
            return newContent;
          }
        }
      }
      
      return null;
    }

    // Convert stored data back to proper types
    const content: ResourceContent = {
      key: row.key,
      resourceKey: row.resource_key,
      resourceId: row.resource_id,
      server: row.server,
      owner: row.owner,
      language: row.language,
      type: row.type as any, // ResourceType
      bookCode: row.book_code || undefined,
      articleId: row.article_id || undefined,
      content: JSON.parse(row.content) as ProcessedContent,
      lastFetched: new Date(row.last_fetched),
      cachedUntil: row.cached_until ? new Date(row.cached_until) : undefined,
      checksum: row.checksum || undefined,
      size: row.size,
      sourceSha: row.source_sha || undefined,
      sourceCommit: row.source_commit || undefined,
    };

    // Debug: Log retrieved content structure
    console.log(`üì§ Retrieved content from DB for ${row.key}:`, {
      type: content.type,
      contentKeys: Object.keys(content.content),
      hasNotes: !!(content.content as any).notes,
      hasArticle: !!(content.content as any).article,
      hasChapters: !!(content.content as any).chapters,
    });
    
    return content;
  }

  /**
   * Save resource content to storage
   */
  async saveResourceContent(content: ResourceContent): Promise<void> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    

    // Generate resourceKey from content key
    const keyParts = content.key.split('/');
    const resourceKey = keyParts.slice(0, -1).join('/');

    await db.runAsync(
      `INSERT OR REPLACE INTO resource_content 
       (key, resource_key, resource_id, server, owner, language, type, book_code, article_id, 
        content, last_fetched, cached_until, checksum, size, source_sha, source_commit, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        content.key,
        resourceKey,
        content.resourceId,
        content.server,
        content.owner,
        content.language,
        content.type,
        content.bookCode || null,
        content.articleId || null,
        JSON.stringify(content.content),
        content.lastFetched.getTime(),
        content.cachedUntil?.getTime() || null,
        content.checksum || null,
        content.size,
        content.sourceSha || null,
        content.sourceCommit || null,
        Date.now()
      ]
    );

    // Update storage statistics
    await this.updateStorageStats();

    
  }

  /**
   * Get multiple content items by keys (batch operation)
   */
  async getMultipleContent(keys: string[]): Promise<ResourceContent[]> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    if (keys.length === 0) return [];

    

    const placeholders = keys.map(() => '?').join(',');
    const rows = await db.getAllAsync(
      `SELECT * FROM resource_content WHERE key IN (${placeholders})`,
      keys
    ) as any[];

    const results: ResourceContent[] = rows.map(row => ({
      key: row.key,
      resourceKey: row.resource_key,
      resourceId: row.resource_id,
      server: row.server,
      owner: row.owner,
      language: row.language,
      type: row.type as any,
      bookCode: row.book_code || undefined,
      articleId: row.article_id || undefined,
      content: JSON.parse(row.content) as ProcessedContent,
      lastFetched: new Date(row.last_fetched),
      cachedUntil: row.cached_until ? new Date(row.cached_until) : undefined,
      checksum: row.checksum || undefined,
      size: row.size,
      sourceSha: row.source_sha || undefined,
      sourceCommit: row.source_commit || undefined,
    }));

    
    return results;
  }

  /**
   * Save multiple content items (batch operation with transaction)
   */
  async saveMultipleContent(contents: ResourceContent[]): Promise<void> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    if (contents.length === 0) return;

    

    await db.withTransactionAsync(async () => {
      for (const content of contents) {
        const keyParts = content.key.split('/');
        const resourceKey = keyParts.slice(0, -1).join('/');

        await db.runAsync(
          `INSERT OR REPLACE INTO resource_content 
           (key, resource_key, resource_id, server, owner, language, type, book_code, article_id, 
            content, last_fetched, cached_until, checksum, size, source_sha, source_commit, updated_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            content.key,
            resourceKey,
            content.resourceId,
            content.server,
            content.owner,
            content.language,
            content.type,
            content.bookCode || null,
            content.articleId || null,
            JSON.stringify(content.content),
            content.lastFetched.getTime(),
            content.cachedUntil?.getTime() || null,
            content.checksum || null,
            content.size,
            content.sourceSha || null,
            content.sourceCommit || null,
            Date.now()
          ]
        );
      }
    });

    // Update storage statistics
    await this.updateStorageStats();

    
  }

  /**
   * Begin a transaction for atomic operations
   */
  async beginTransaction(): Promise<StorageTransaction> {
    await this.initialize();
    return new SimplifiedDrizzleTransaction(this.databaseManager);
  }

  /**
   * Clear expired content based on cachedUntil timestamps
   */
  async clearExpiredContent(): Promise<void> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    await db.runAsync(
      'DELETE FROM resource_content WHERE cached_until IS NOT NULL AND cached_until < ?',
      [Date.now()]
    );

    // Update storage statistics
    await this.updateStorageStats();

    
  }

  /**
   * Clear all content (keep metadata)
   */
  async clearAllContent(): Promise<void> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    

    await db.runAsync('DELETE FROM resource_content');

    // Update storage statistics
    await this.updateStorageStats();

    
  }

  /**
   * Get storage information and statistics
   */
  async getStorageInfo(): Promise<StorageInfo> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    const result = await db.getFirstAsync(
      'SELECT COUNT(*) as itemCount, COALESCE(SUM(size), 0) as totalSize FROM resource_content'
    ) as any;

    // Get last cleanup time from storage stats
    const statsRow = await db.getFirstAsync(
      'SELECT last_cleanup FROM storage_stats WHERE key = ?',
      ['global']
    ) as any;

    const lastCleanup = statsRow ? new Date(statsRow.last_cleanup) : new Date();

    return {
      totalSize: result.totalSize || 0,
      availableSpace: -1, // Will be calculated in checkQuota
      itemCount: result.itemCount || 0,
      lastCleanup,
    };
  }

  /**
   * Check storage quota (simplified for mobile)
   */
  async checkQuota(): Promise<QuotaInfo> {
    const info = await this.getStorageInfo();
    const defaultQuota = 200 * 1024 * 1024; // 200MB default for mobile
    
    return {
      used: info.totalSize,
      available: Math.max(0, defaultQuota - info.totalSize),
      total: defaultQuota,
      nearLimit: info.totalSize > (defaultQuota * 0.8) // 80% threshold
    };
  }

  /**
   * Update storage statistics
   */
  private async updateStorageStats(): Promise<void> {
    const db = this.databaseManager.getSqliteDb();

    const stats = await db.getFirstAsync(
      'SELECT COUNT(*) as itemCount, COALESCE(SUM(size), 0) as totalSize FROM resource_content'
    ) as any;

    await db.runAsync(
      'UPDATE storage_stats SET total_size = ?, item_count = ?, updated_at = ? WHERE key = ?',
      [stats.totalSize || 0, stats.itemCount || 0, Date.now(), 'global']
    );
  }

  /**
   * Close the database connection (delegates to DatabaseManager)
   */
  async close(): Promise<void> {
    
    this.isInitialized = false;
  }

  /**
   * Delete all storage data (useful for testing)
   */
  async deleteAllData(): Promise<void> {
    await this.initialize();
    const db = this.databaseManager.getSqliteDb();

    

    await db.runAsync('DELETE FROM resource_content');
    await db.runAsync('DELETE FROM resource_metadata');
    await db.runAsync('DELETE FROM storage_stats');

    // Reinitialize storage stats
    await this.initializeStorageStats();

    
  }

  /**
   * Get the database name (useful for debugging)
   */
  getDatabaseName(): string {
    return 'unified-simplified-drizzle-database';
  }
}

/**
 * Simplified Drizzle Transaction implementation
 */
class SimplifiedDrizzleTransaction implements StorageTransaction {
  private operations: (() => Promise<void>)[] = [];
  private isCommitted = false;
  private isRolledBack = false;

  constructor(private databaseManager: DatabaseManager) {}

  async save(content: ResourceContent): Promise<void> {
    if (this.isCommitted || this.isRolledBack) {
      throw new Error('Transaction already completed');
    }

    this.operations.push(async () => {
      const db = this.databaseManager.getSqliteDb();
      
      // Generate resourceKey from content key
      const keyParts = content.key.split('/');
      const resourceKey = keyParts.slice(0, -1).join('/');

      await db.runAsync(
        `INSERT OR REPLACE INTO resource_content 
         (key, resource_key, resource_id, server, owner, language, type, book_code, article_id, 
          content, last_fetched, cached_until, checksum, size, source_sha, source_commit, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          content.key,
          resourceKey,
          content.resourceId,
          content.server,
          content.owner,
          content.language,
          content.type,
          content.bookCode || null,
          content.articleId || null,
          JSON.stringify(content.content),
          content.lastFetched.getTime(),
          content.cachedUntil?.getTime() || null,
          content.checksum || null,
          content.size,
          content.sourceSha || null,
          content.sourceCommit || null,
          Date.now()
        ]
      );
    });
  }

  async delete(key: string): Promise<void> {
    if (this.isCommitted || this.isRolledBack) {
      throw new Error('Transaction already completed');
    }

    this.operations.push(async () => {
      const db = this.databaseManager.getSqliteDb();
      await db.runAsync('DELETE FROM resource_content WHERE key = ?', [key]);
    });
  }

  async commit(): Promise<void> {
    if (this.isCommitted || this.isRolledBack) {
      throw new Error('Transaction already completed');
    }

    const db = this.databaseManager.getSqliteDb();

    await db.withTransactionAsync(async () => {
      for (const operation of this.operations) {
        await operation();
      }
    });

    this.isCommitted = true;
    
  }

  async rollback(): Promise<void> {
    if (this.isCommitted || this.isRolledBack) {
      throw new Error('Transaction already completed');
    }

    this.operations = [];
    this.isRolledBack = true;
    
  }
}

// Export factory functions for easy usage
export const createSimplifiedDrizzleStorageAdapter = (): SimplifiedDrizzleStorageAdapter => {
  return new SimplifiedDrizzleStorageAdapter();
};

// Export the main class as default
export default SimplifiedDrizzleStorageAdapter;

