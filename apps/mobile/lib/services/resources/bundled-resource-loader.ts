/**
 * Bundled Resource Loader
 * Auto-generated by resource-zip-bundler.ts
 * 
 * Loads bundled resource ZIP files and extracts them to the document directory.
 * Each resource is a separate ZIP file to work around Metro's 20MB limitation.
 */

import { Asset } from 'expo-asset';
import { Directory, File, Paths } from 'expo-file-system';

export interface BundledResource {
  id: string;
  name: string;
  language: string;
  owner: string;
  server: string;
  resourceKey: string; // Format: server/owner/language/id
  assetModule: any;
}

// Resource definitions (auto-generated)
export const BUNDLED_RESOURCES: BundledResource[] = [
  {
    id: 'ugnt',
    name: 'Greek New Testament',
    language: 'el-x-koine',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/el-x-koine/ugnt',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_el-x-koine_ugnt.zip')
  },
  {
    id: 'ta',
    name: 'Translation Academy',
    language: 'en',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/en/ta',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_en_ta.zip')
  },
  {
    id: 'tn',
    name: 'Translation Notes',
    language: 'en',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/en/tn',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_en_tn.zip')
  },
  {
    id: 'tq',
    name: 'Translation Questions',
    language: 'en',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/en/tq',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_en_tq.zip')
  },
  {
    id: 'tw',
    name: 'Translation Words',
    language: 'en',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/en/tw',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_en_tw.zip')
  },
  {
    id: 'twl',
    name: 'Translation Words Links',
    language: 'en',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/en/twl',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_en_twl.zip')
  },
  {
    id: 'ult',
    name: 'Unlocked Literal Translation',
    language: 'en',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/en/ult',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_en_ult.zip')
  },
  {
    id: 'ust',
    name: 'Unlocked Simplified Translation',
    language: 'en',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/en/ust',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_en_ust.zip')
  },
  {
    id: 'uhb',
    name: 'Hebrew Bible',
    language: 'hbo',
    owner: 'unfoldingWord',
    server: 'git.door43.org',
    resourceKey: 'git.door43.org/unfoldingWord/hbo/uhb',
    assetModule: require('../../../assets/bundled/git.door43.org_unfoldingWord_hbo_uhb.zip')
  }
];

// Resource lookup map by resourceKey for fast access
const RESOURCE_MAP = new Map<string, BundledResource>(
  BUNDLED_RESOURCES.map(r => [r.resourceKey, r])
);

// Extraction lock to prevent duplicate extractions
const EXTRACTION_LOCKS = new Map<string, Promise<void>>();

/**
 * Load and extract a single bundled resource
 * Uses a lock mechanism to prevent duplicate extractions of the same resource
 */
export async function loadBundledResource(resource: BundledResource): Promise<void> {
  // Check if extraction is already in progress
  const existingLock = EXTRACTION_LOCKS.get(resource.resourceKey);
  if (existingLock) {
    console.log(`‚è≥ ${resource.id} extraction already in progress, waiting...`);
    return existingLock;
  }
  
  // Create new extraction promise
  const extractionPromise = performExtraction(resource);
  EXTRACTION_LOCKS.set(resource.resourceKey, extractionPromise);
  
  try {
    await extractionPromise;
  } finally {
    // Remove lock after extraction completes (success or failure)
    EXTRACTION_LOCKS.delete(resource.resourceKey);
  }
}

/**
 * Perform the actual extraction (internal method)
 */
async function performExtraction(resource: BundledResource): Promise<void> {
  const startTime = Date.now();
  
  console.log(`üì¶ Loading ${resource.id} (${resource.language})...`);
  
  try {
    // Load the asset
    const asset = Asset.fromModule(resource.assetModule);
    
    if (!asset.downloaded) {
      await asset.downloadAsync();
    }
    
    if (!asset.localUri) {
      throw new Error(`Asset ${resource.id} has no localUri`);
    }
    
    // Read ZIP file
    const zipFile = new File(asset.localUri);
    const zipData = await zipFile.bytes();
    
    // Extract using JSZip (imported dynamically to avoid loading if not needed)
    const JSZip = (await import('jszip')).default;
    const zip = await JSZip.loadAsync(zipData);
    
    // Target directory structure: document/uw-translation-resources/server/owner/language/resourceId/
    // Create directories step by step (Directory.create() doesn't create parent directories)
    const basePath = Paths.document;
    const pathParts = ['uw-translation-resources', resource.server, resource.owner, resource.language, resource.id];
    
    let currentDir = basePath;
    for (const part of pathParts) {
      const nextDir = new Directory(currentDir, part);
      if (!nextDir.exists) {
        nextDir.create();
      }
      currentDir = nextDir;
    }
    
    const targetDir = currentDir;
    
    // Extract all files
    const fileNames = Object.keys(zip.files);
    let filesExtracted = 0;
    
    for (const fileName of fileNames) {
      const zipEntry = zip.files[fileName];
      
      if (zipEntry.dir) continue;
      
      const content = await zipEntry.async('uint8array');
      
      // Handle nested paths (e.g., content/gen.json.zip)
      const pathParts = fileName.split('/');
      const fileNameOnly = pathParts[pathParts.length - 1];
      const dirPath = pathParts.slice(0, -1);
      
      // Create nested directories
      let currentDir = targetDir;
      for (const dirName of dirPath) {
        const nextDir = new Directory(currentDir.uri, dirName);
        if (!nextDir.exists) {
          nextDir.create();
        }
        currentDir = nextDir;
      }
      
      // Write file
      const targetFile = new File(currentDir.uri, fileNameOnly);
      await targetFile.write(content);
      filesExtracted++;
    }
    
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`‚úÖ ${resource.id}: Extracted ${filesExtracted} files in ${duration}s`);
    
  } catch (error) {
    console.error(`‚ùå Failed to load ${resource.id}:`, error);
    throw error;
  }
}

/**
 * Load all bundled resources
 */
export async function loadAllBundledResources(
  onProgress?: (current: number, total: number, resourceId: string) => void
): Promise<void> {
  console.log(`üöÄ Loading ${BUNDLED_RESOURCES.length} bundled resources...`);
  const startTime = Date.now();
  
  for (let i = 0; i < BUNDLED_RESOURCES.length; i++) {
    const resource = BUNDLED_RESOURCES[i];
    
    if (onProgress) {
      onProgress(i + 1, BUNDLED_RESOURCES.length, resource.id);
    }
    
    await loadBundledResource(resource);
  }
  
  const duration = ((Date.now() - startTime) / 1000).toFixed(2);
  console.log(`‚úÖ All resources loaded in ${duration}s`);
}

/**
 * Get a bundled resource by its resourceKey (server/owner/language/id)
 */
export function getBundledResourceByKey(resourceKey: string): BundledResource | undefined {
  return RESOURCE_MAP.get(resourceKey);
}

/**
 * Check if a specific resource is available
 */
export function hasBundledResource(resourceKey: string): boolean {
  return RESOURCE_MAP.has(resourceKey);
}

/**
 * Check if resources are already extracted
 */
export function areBundledResourcesExtracted(): boolean {
  const resourcesDir = new Directory(Paths.document, 'uw-translation-resources');
  return resourcesDir.exists;
}

/**
 * Get resource manifest grouped by language
 */
export function getResourceManifest() {
  return {
    'el-x-koine': [
      { id: 'ugnt', name: 'Greek New Testament' }
    ],
    'en': [
      { id: 'ta', name: 'Translation Academy' },
      { id: 'tn', name: 'Translation Notes' },
      { id: 'tq', name: 'Translation Questions' },
      { id: 'tw', name: 'Translation Words' },
      { id: 'twl', name: 'Translation Words Links' },
      { id: 'ult', name: 'Unlocked Literal Translation' },
      { id: 'ust', name: 'Unlocked Simplified Translation' }
    ],
    'hbo': [
      { id: 'uhb', name: 'Hebrew Bible' }
    ]
  };
}
